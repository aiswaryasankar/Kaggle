%%%%% Don't Make Changes Below Here %%%%%
\documentclass{article}\usepackage[utf8]{inputenc}\usepackage[margin=0.4cm,top=0.4cm,bottom=0.4cm]{geometry}\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}\usepackage{calligra}\usepackage{tikz}\usetikzlibrary{matrix,fit,chains,calc,scopes}\usepackage{tcolorbox}\tcbuselibrary{skins}\tcbset{Baystyle/.style={sharp corners,enhanced,boxrule=6pt,colframe=Aquamarine,height=\textheight,width=\textwidth,borderline={8pt}{-11pt}{},}}\usepackage{amsmath,amssymb,amsthm,tikz,tkz-graph,color,chngpage,soul,hyperref,csquotes,graphicx,floatrow}\newcommand*{\QEDB}{\hfill\ensuremath{\square}}\newtheorem*{prop}{Proposition}\renewcommand{\theenumi}{\alph{enumi}}\usepackage[shortlabels]{enumitem}\usetikzlibrary{matrix,calc}\MakeOuterQuote{"}\newtheorem{theorem}{Theorem} \usetikzlibrary{shapes} \usepackage{lipsum}\usepackage{tabularx,ragged2e,booktabs,caption}\tcbuselibrary{breakable}\newenvironment{yframed}{\begin{tcolorbox}[breakable,colback=gray!3,title after break={\textit{\color{red}Solution (cont.)}},colbacktitle=gray!3, coltitle=black,titlerule=-1pt] }{\end{tcolorbox}}\newtcolorbox{mybox}{colback=black!15!white, colframe=white,arc=12pt}\newtcolorbox{myboxot}{colback=green!15!white, colframe=white,arc=12pt,width=110pt, height=27pt}\newtcbox{\mylib}{enhanced,boxrule=0pt,top=0mm,bottom=0mm,right=0mm,left=4mm,arc=4pt,boxsep=9pt,before upper={\vphantom{dlg}},colframe=green!50!black,coltext=green!25!black,colback=green!10!white,overlay={\begin{tcbclipinterior}\fill[green!75!blue!50!white] (frame.south west)rectangle node[text=white,font=\sffamily\bfseries\tiny,rotate=90] {Problem} ([xshift=4mm]frame.north west);\end{tcbclipinterior}}}\newtcbox{\mylibot}{enhanced,boxrule=0pt,top=0mm,bottom=0mm,right=0mm,arc=4pt,boxsep=9pt,before upper={\vphantom{dlg}},colframe=green!50!black,coltext=green!25!black,colback=green!10!white,overlay={\begin{tcbclipinterior}\fill[red!75!blue!50!white] (frame.south west)rectangle node[text=white,font=\sffamily\bfseries\tiny,rotate=90] {Other} ([xshift=4mm]frame.north west);\end{tcbclipinterior}}}
\def\Title{\begin{tcolorbox}[Baystyle,]{\begin{center}\vspace*{0.14\textheight}
{\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}}
\rule{\textwidth}{0.4pt}\\[0.2\baselineskip]{\fontsize{45}{45}\scshape CS 170: Efficient Algorithms and \\[-0.3\baselineskip] Intractable Problems \\[0.2\baselineskip] \calligra Spring 2017 \\[0.2\baselineskip]}
{\rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt}}
\rule{\textwidth}{1.6pt}\\[\baselineskip]\vspace{0.05\textheight}{{\fontsize{45}{45}\scshape$\bullet$\\ {Homework 4}\\\vspace*{0.01\textheight} }{{\fontsize{18}{18}\scshape{Due on Tuesday, Februrary 28h, 2017 at 11:59am\\}}}\fontsize{45}{45}\scshape$\bullet$  \\}\vspace*{0.1\textheight}{\fontsize{12}{12}\calligra Solutions by\\}{\fontsize{28}{28}\scshape \Name \\}\vspace*{0.01\textheight}{\fontsize{12}{12}\scshape \SID} \\\vspace*{0.05\textheight}{\fontsize{12}{12}\calligra In collaboration with\\}\vspace*{0.01\textheight}{\fontsize{12}{12}\scshape \Collabs} \\\vspace*{0.05\textheight}\end{center}}\end{tcolorbox}\newgeometry{margin=0.75in}}\def\BeginSolution{\begin{yframed}\textbf{\color{red}Solution }}\def\EndSolution{\end{yframed}}
\usepackage{algorithm}\usepackage[noend]{algpseudocode}\makeatletter\def\BState{\State\hskip-\ALG@thistlm}\makeatother\def\T{\indent}\def\star{\bigstar}
\usetikzlibrary{arrows}
\usepackage {tikz}
\usetikzlibrary {positioning}
%\usepackage {xcolor}
\definecolor {processblue}{cmyk}{0.96,0,0,0}

%%%%% Don't Make Changes Above Here %%%%%

%%%%% Template Begins Here %%%%%
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\def\Name{Aiswarya Sankar}  % Your name
\def\SID{26347114}  % Your student ID number
\def\Collabs{Jacob Holesinger, Sudeep Dasari} % Your collaborators here with a comma between each person's name. Write None if no collaborators. Don't leave blank.


\pagestyle{empty}
\begin{document}
\Title
%%%% Problem 1 Starts Here %%%%
\vspace{-2mm}\noindent\begin{mybox}{\begin{center}\textbf{\color{black}Problem 1: Short Questions}\end{center}}\end{mybox}\vspace{-2mm}
\begin{myboxot}\noindent\textbf{$\star\star$ Level}\end{myboxot} 

\noindent For the following claims, answer yes or no and provide justification. Consider an arbitrary graph $G$ with positive edge weights. Shortest path means least cost path.
\begin{enumerate}
\item Let $G$ be a connected undirected graph with positive length on all the edges. Let $s$ be a fixed vertex. Let $d(s, v)$ denote the distance from vertex $s$ to vertex $v$, i.e., the length of the shortest path from $s$ to $v$. If we choose the vertex $v$ that makes $d(s,v)$ as small as possible, subject to the requirement that $v\neq s$, then does every edge on the path from $s$ to $v$ have to be part of every minimum spanning tree of $G$?
\BeginSolution % 1a
% Solution Here
We can disprove this by counterexample.  For example given the graph with the following edges and vertices we have


\begin {center}
\begin {tikzpicture}[-latex ,auto ,node distance =4 cm and 5cm ,on grid ,
semithick ,
state/.style ={ circle ,top color =white , bottom color = processblue!20 ,
draw,processblue , text=blue , minimum width =1 cm}]
\node[state] (A)
{$A$};
\node[state] (B) [above left=of A] {$B$};
\node[state] (C) [above right =of A] {$C$};
\path (A) edge [bend left =25] node[below =0.15 cm]{$3$} (B);
\path (A) edge [bend right =25] node[below =0.15 cm] {$3$} (C);
\path (B) edge [bend right = -15] node[below =0.15 cm] {$1$} (C);
\end{tikzpicture}
\end{center}
Given this graph we can show that a valid MST would include edges BC and AB or AC.  It wouldn't include both AC and AB because that would not fit the invariant that a minimum spanning tree minimizes the total weight of the graph's edges.  Thus every edge on the path from s to v isn't a part of every minimum spanning tree of G and we have provided a counterexample.
\EndSolution
\item The same question as above, except now no two edges can have the same length.
\BeginSolution % 1b
% Solution Here
This is true.  We know that since every vertex in the graph must be connected we can show that the minimum path leaving a given vertex must be included in the MST if all the edge weights are unique.  \\
\textbf{Proof by contradiction:}  Assume that the every edge on the path from s to v isn't a part of every MST of G.  This means that out of a vertex there is an edge E' that is chosen over E where E' > E.  This however invalidates the MST invariant that the total sum of the edge weights must be minimized.  Therefore by contradiction we have shown that every edge on the path from s to v must be a part of every minimum spanning tree of G.
\EndSolution
\end{enumerate}

%%%% Problem 1 Ends Here %%%%
\clearpage

%%%% Problem 2 Starts Here %%%%
\vspace{-2mm}\noindent\begin{mybox}{\begin{center}\textbf{\color{black}Problem 2: Huffman Encoding}\end{center}}\end{mybox}\vspace{-2mm}
\begin{myboxot}\noindent\textbf{$\star\star$ Level}\end{myboxot}

\noindent We use Huffman's algorithm to obtain an encoding of alphabet ${a, b, c}$ with frequencies $f_a,f_b,f_c$. In each of the following cases, either give an example of the frequencies $(f_a, f_b, f_c)$ that would yield the specified code, or explain why the code cannot possibly be obtained (no matter what the frequencies are)>

\begin{enumerate}
\item Code: $\{0, 10, 11\}$
\BeginSolution % 2a
% Solution Here
This code can be obtainded if $f_{a} > f_{b} \geq f_{c}$.  Therefore we can assign $f_{a} = 0.5, f_{b} = .25, f_{c} = .25$.  
\EndSolution
\item Code: $\{0, 1, 00\}$
\BeginSolution % 2b
% Solution Here
This code isn't a valid Huffman encoding since 0 is a prefix of 00 and Huffman encoding needs to guarantee that all codes are prefix free.
\EndSolution
\item Code: $\{10, 01, 00\}$
\BeginSolution % 2c
% Solution Here
This is also not a valid encoding for two reasons.  First we can show that this solution isn't a full binary tree. In order to be a full binary tree each node must have either 0 or 2 children.  In this example however node 1 has 1 child 10.  The reason this is invalid is that we could instead use the encoding 1, 01, 00 which would also be a valid encoding and give us a smaller overall sum of weights.
\EndSolution
\end{enumerate}

%%%% Problem 2 Ends Here %%%%
\clearpage

%%%% Problem 3 Starts Here %%%%
\vspace{-2mm}\noindent\begin{mybox}{\begin{center}\textbf{\color{black}Problem 3: Preventing Conflict}\end{center}}\end{mybox}\vspace{-2mm}
\begin{myboxot}\noindent\textbf{$\star\star\star\star$ Level}\end{myboxot} 

\noindent A group of $n$ guests shows up to a house for a party, and any two guests are either friends or enemies. There are two rooms in the house, and the host wants to distribute guests among the rooms, breaking up as many pairs of enemies as possible. The guests are all waiting outside the house and are impatient to get in, so the host needs to assign them to the two rooms quickly, even if this means that it's not the best possible solution. Come up with an efficient algorithm that breaks up at least half the number of pairs of enemies as the best possible solution, and prove your answer.\\
Hint: Try assigning guests one at a time. Consider how many pairs of enemies are broken up with each iteration.
\BeginSolution\\\\ % 3
% Solution Here
\textbf{Main Idea}\\
We want to assign each person to a room one at a time.  Thus intuitively we ask the question: given a set A of people in room 1 and set B of people in room 2, which room would we rather put person x in?  We want to put person x in the room with fewer enemies because this maximizes the number of enemy ties broken with that placement.  Thus the question becomes, how do we efficiently compute the number of enemies a person has in each room?  We know that sets implemented using hashtable has constant lookup time.  Thus as we place each person in a room we will store the set of people in that room in a hashset.\\
Our graph is represented with nodes as people and edges as enemy ties.  Thus for each person we are going to place in a room, we iterate through the person's edges and place the person in the corresponding room.  \\


\textbf{Psuedocode}\\
\begin{lstlisting}
	def separateEnemies(enemies):
		set1 = {}
		set2 = {}
		for person in enemies:
			enemiesSet1, enemiesSet2 = 0
			for enemy in person.neighbors:
				if enemy in set1:
					enemiesSet1 += 1
				if enemy in set2:
					enemiesSet2 += 1
				else:
					add(person) to smaller set
			if enemiesInSet1 >= enemiesInSet2:
				set1.add(person)
			else:
				set2.add(person)
			
\end{lstlisting}

\textbf{Proof of Correctness}\\
We need to prove that this algorithm will break up at least half the number of pairs of enemies.  We can prove this because for each person we are placing him or her in the set in which he or she has fewer enemies.  Assume a person x has n enemies.  Then there are the following conditions to consider:
$$ 
\begin{cases}
enemiesRoom1 > n/2: \text{ break $>$ n/2 enemies} \\
enemiesRoom1 == n/2: \text{ break n/2 enemies} \\
enemiesRoom1 < n/2: \text{ break $>$ n/2 enemies} \\
\end{cases} $$
This way we are guaranteed to break up at least n/2 enemy pairs each time where n is the total number of enemies a person has.  Therefore since we do this for each person we guarantee that as a sum we will break n/2 enemy pairs.\\

\textbf{Runtime Analysis}\\
This will be $O(E)$ where E is the number of edges.  We will represent this problem as a graph where edges are enemy relationships and the people in each room is a hashset.  Therefore we have constant time lookup to see if a person is in a given room.  For each edge we will look it up only once.

\EndSolution
%%%% Problem 3 Ends Here %%%%
\clearpage

%%%% Problem 4 Starts Here %%%%
\vspace{-2mm}\noindent\begin{mybox}{\begin{center}\textbf{\color{black}Problem 4: Graph Subsets}\end{center}}\end{mybox}\vspace{-2mm}
\begin{myboxot}\noindent\textbf{$\star\star$ Level}\end{myboxot} 

\noindent Let $G = (V, E)$ be a connected, undirected graph, with edge weights $w(e)$ on each edge $e$. Some edge weights \textit{might be negative}. We want to find a subset of edges $E' \subseteq E$ such that $G' = (V, E')$ is connected, and the sum of the edge weights in $E'$ is as small as possible.
\begin{enumerate}[1.]
\item Is it guaranteed that the optimal solution $E$ to this problem will always form a tree?
\BeginSolution % 4 (1)
% Solution Here
No because you may have a negative cycle in which case if you include all the edges you do not have a tree.  There is also the case where all the edges in a fully connected graph is negative in which case you definitely wouldn't have a tree.
\EndSolution
\item Does Kruskal's algorithm solve this problem? If yes, explain why in a sentence or two; if no, give a small counterexample.
\BeginSolution % 4 (2)
% Solution Here
No.  Kruskal's doesn't solve this problem because Kruskal's can't find negative cycles.
\EndSolution
\item Briefly describe an efficient algorithm for this problem. Just the main idea is enough (1-3 sentences). No need for a 4-part solution.
\BeginSolution % 4 (3)
% Solution Here
There are two ways we can do this.  First we can select all the negative weight edges since we know that all the negative edges must be in the final lowest edge weight graph.  You can always reduce the total weight by adding a negative edge.  Once you find all of these edges you can then run Kruskal's algorithm to find a minimum spanning tree between these components to create a connected subset of edges.
\EndSolution
\end{enumerate}
%%%% Problem 4 Ends Here %%%%
\clearpage

%%%% Problem 5 Starts Here %%%%
\vspace{-2mm}\noindent\begin{mybox}{\begin{center}\textbf{\color{black}Problem 5: Arbitrage}\end{center}}\end{mybox}\vspace{-2mm}
\begin{myboxot}\noindent\textbf{$\star\star\star$ Level}\end{myboxot} 

\noindent Shortest-path algorithms can also be applied to currency trading. Suppose we have $n$ currencies $C = {c_1, c_2, \ldots , c_n}$: e.g., dollars, Euros, bitcoins, dogecoins, etc. For any pair $i, j$ of currencies, there is an exchange rate $r_{i, j}$: you can buy $r_{i, j}$ unites of currency $c_j$ at the price of one unit of currency $c_i$. Assume that $r_{i, j} = 1$ and $r_{i, j} \geq 0$ for all $i, j$.

\begin{enumerate}[(a)]
\item The Foreign Exchange Market Organization (FEMO) has hired Oski, a CS170 alumnus, to make sure that it is not possible to generate a profit through a cycle of exchanges, and end with more than one unit of currency $i$. (That is called \textit{arbitrage}.) Give an efficient algorithm for the following problem: given a set of exchange rates $r_{i, j}$ and two specific currencies $s, t$, find the most advantageous sequence of currency exchanges for converting currency $s$ into currency $t$. We recommend that you represent the currencies and rates by a graph whose edge lengths are real numbers.
\BeginSolution\\\\ % 5 (a)
% Solution Here
\textbf{Main Idea}\\
There are a few primary concerns we have to take into consideration for this problem.\\
\begin{itemize}
\item Edges with fractional exchange rates have a similar function to negative edges since when you multiply a number by a fraction the result is smaller.  Thus if we are to try to maximize the product, these fractional edges will create smaller weights.  
\item We also need to note that we aren't minimizing the path but instead maximizing the path.
\item Lastly we are multiplying the edge weights instead of adding the edges.
\end{itemize}
We note that the presence of negative edge weights excludes the option of using Dijkstra's algorithm.  Therefore we must use Bellman Ford to find the maximum path with the above modifications.\\

\textbf{Psuedocode}\\
\begin{lstlisting}
def maxPath:
	for all c in currencies:
		weight(c) = inf
		prev(c) = nil
	dist(s) = 0
	repeat |c| - 1 times:
		for all c_i, c_j in rates:
			rate(c_j) = max{dist(c_j), dist(c_i) * rate(c_i, c_j)}
	
	return dist(t), createPath(t)
\end{lstlisting}

\textbf{Run Time Analysis}\\
The runtime of this algorithm will be proportional to the number of vertices in the graph.  We need to update each edge with each iteration due to the fact that there are negative edges and thus we can't maintain the invariant from Dijkstra's that the path so far is the shortest to the given point.  Also since we know that the graph is fully connected - there is an exchange rate between every two currencies - we determine that the runtime is $O(|V||E|)$.\\

\textbf{Proof of Correctness}\\
This algorithm is correct because with each update we are going in and modifying the weight if there is a newly found longer path to the given vertex.  Thus we don't assume that we have found the longest path at any given point until we consider all possible paths to that vertex.

\EndSolution
\item In the economic downturn of 2016, the FEMO had to downsize and let Oski go, and the currencies are changing rapidly, unfettered and unregulated. As a responsible citizen and in light of what you saw in lecture this week, this makes you very concerned: it many now be possible to find currencies $c_{i_1}, \ldots, c_{i_k}$ such that $r_{i_1, i_2} \times r_{i_2, i_3} \times \ldots \times r_{i_{k-1}, i_k} \times r_{i_k, i_1} > 1$. This means that by starting with one unit of currency $c_{i_1}$ and then successively converting it to currencies $c_{i_2}, c_{i_3}, \ldots , c_{i_k}$ and finally back to $c_{i_1}$, you would end up with more than one unit of currency $c_{i_1}$. Such anomalies last only a fraction of a minute on the currency exchange, but they provide and opportunity for profit.\\
You decide to step up and help out the World Bank. Given an efficient algorithm for detecting the presence of such an anomaly. You may use the same graph representation as for part (a).
\BeginSolution\\\\ % 5 (b)
% Solution Here
\textbf{Main Idea}\\
We note that from the previous part we have 'negative edges' if an edge has a fractional weight.  This is because the product with a fraction reduces the overall weight.  When using Bellman Ford we know that if we run the iteration V times and see an update on the last iteration we have found a cycle.  Therefore we run the algorithm V times and check the last update.\\

\textbf{Psuedocode}\\
\begin{lstlisting}
def findArbitrage:
	for all c in currencies:
		weight(c) = inf
		prev(c) = nil
	dist(s) = 0
	repeat |c| - 1 times:
		for all c_i, c_j in rates:
			rate(c_j) = max{dist(c_j), dist(c_i) * rate(c_i, c_j)}
	for all c_i, c_j in rates:
		if dist(c_i) * rate(c_i, c_j) > max{dist(c_j):
			return True
	return False
\end{lstlisting}

\textbf{Proof of Correctness}\\
We have to prove that on the Vth iteration we will detect a cycle if one exists.  Any path from s to t can have at most |V-1| edges because we assume there are no cycles.  On the last update if there is still an update in the length then we know that there is a cycle because no path can have more than V edges.\\

\textbf{Runtime Analysis}\\
The runtime of this is the same as the previous part.  We are running Bellman Ford on this and therefore will have a runtime of $O(V^{2})$.  

\EndSolution
\end{enumerate}
%%%% Problem 5 Ends Here %%%%
\clearpage

\end{document}
%%%%% Template Ends Here %%%%%